<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Atsushi Mori&#39;s blog</title>
    <link>http://jp.atsushimori.com/</link>
    <description>Recent content on Atsushi Mori&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Sun, 05 Mar 2017 16:41:56 +0900</lastBuildDate>
    <atom:link href="http://jp.atsushimori.com/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>未来は量子力学の中にある</title>
      <link>http://jp.atsushimori.com/blog/</link>
      <pubDate>Sun, 05 Mar 2017 16:41:56 +0900</pubDate>
      
      <guid>http://jp.atsushimori.com/blog/</guid>
      <description>

&lt;p&gt;P君と「巡回セールスマン問題」のアルゴリズムについて話していた中で、量子力学のさわりについて触れ、恐ろしく可能性を感じた話。&lt;/p&gt;

&lt;h2 id=&#34;量子ビットの存在&#34;&gt;量子ビットの存在&lt;/h2&gt;

&lt;p&gt;量子ビットについて話す前に量子力学について、触れておこう。量子力学は見方を変えると厨二臭がする分野に聞こえるのだけれど、実際にはそうではない、一般社会における現実を超えた世界であるため、説明が難しいあるいは確立されていない部分が多いということなんだろう。ニュースなど身近な例で言うと、「量子コンピュータ」というものが存在する。それは「スーパーコンピュータ」として知られる「京」よりも計算効率の良い夢の技術として位置づけられている。&lt;/p&gt;

&lt;p&gt;昨年にあたる2016年5月に、誰でも触れることができる量子コンピュータとしてIBM Quantum Experienceを発表。量子コンピュータが夢から少し現実味を帯びてきているということである。調べてみると、やっぱりGoogleやAppleもその分野はとうの昔に目をつけていて、実用的な技術として研究を進めている。iPhone7などに搭載されたボタンじゃないボタン、「タップティックエンジン」の仕組みも量子力学の応用による仕組みであることもわかった。&lt;/p&gt;

&lt;p&gt;さて、本題。量子ビットとは何なのか？である。よくデジタルを表現する例えとして、「デジタルは0と1だ」という説明がなされるように、わたしたちが日常的に触れているほとんどの「デジタル」は電気信号を2進数で表記し、徐々に人間にとってわかりやすい表現へと抽象化されていっている。&lt;/p&gt;

&lt;p&gt;量子とは原子より小さな世界の不確定な状態を表す名前であり、電子は「量子」の代表格となっている。わたしたちがこうして電気によって生活を豊かにしているということは、「量子」によって生活を豊かにできる可能性を充分に示唆する事実であるといえる。その不確定な状態をデジタルの世界で表すと、「0」にも「1」にもなりうる状態をもてる、ということである。&lt;/p&gt;

&lt;p&gt;それが量子ビットで、量子ビットを使えると何がすごいかというと、例えば「1+1+1=3」という計算があったとして、1と1と1から3を導き出せるということである。笑&lt;/p&gt;

&lt;p&gt;説明になっていない。通常の演算（足し算や引き算などの計算）は確定しているものを物質的に計算している。ただ、量子ビットを使えると、1と1と1があった瞬間3であるとわかってしまうのである。ここが厨二の根源で、説明にならない説明なのだけれど、どんな研究資料のようなものをみてみても、「そうなる」としか書いておらず、ここが超人的概念なんだろうと思う。ただ、これから紐解いていきたい。&lt;/p&gt;

&lt;p&gt;とにかく量子ビットという状態を作れると、スーパーコンピュータを超える瞬間的な計算が可能になるということだ。夢がある。&lt;/p&gt;

&lt;h2 id=&#34;人工知能と量子コンピュータの関係&#34;&gt;人工知能と量子コンピュータの関係&lt;/h2&gt;

&lt;p&gt;そもそもボクが興味をもったきっかけは、プログラマ的な視点で「（量子に関係ない一般的なものも含んだ）アルゴリズム」→「人工知能」→「量子力学」という興味遷移でたどり着いたのだけど、これは自然な流れで、人工知能と量子力学は密接に関わっている。Googleが研究に力を注いでいるのも人工知能や次世代の技術のためであろう。人工知能を実現するということは、天文学的な数の計算をより短く終えることと言ってもよい。一般的な0と1の計算だと、いくら頑張っても限界地点が見えてしまう。その為、根本の仕様をかえなくてはならない。その可能性を実現する可能性が最も高いのが量子力学という学問であるということだろう。&lt;/p&gt;

&lt;p&gt;つまり、量子力学は人工知能の時代を迎えるこれからにとって必要不可欠な存在であって、数年先にはプログラマーなら大体知っているレベルまで普及する学問となることが予想される。&lt;/p&gt;

&lt;h2 id=&#34;求めているものはこれだ&#34;&gt;求めているものはこれだ&lt;/h2&gt;

&lt;p&gt;ボクはずっと人工知能のビジネスでの抜け道を考えていた。データ量でもビッグデータ用アルゴリズムでも勝てる気がしない。ではどうするか？CPUで軽快に動作する汎用的な人工知能アルゴリズム、それにずっと興味がある。ディープラーニングはたしかにすごいけど、それは通過点でしかないし、第一人間の決断と言うのは一瞬であって、何百代とコンピューターを並べるレベルのエネルギーは絶対に使っていないという実感があるからだ。その一瞬の判断の答えこそ、量子ビットの存在で解決できるのではないかと考えた。通る道は直線ではないけれど、最終的に目指す場所をつなげるのが量子コンピューティングであることを確信した。些細な会話から生まれたヒントだったけど、これは本当にワクワクする話だ。&lt;/p&gt;

&lt;h2 id=&#34;量子アルゴリズムは既存のアルゴリズムを簡単に超える&#34;&gt;量子アルゴリズムは既存のアルゴリズムを簡単に超える&lt;/h2&gt;

&lt;p&gt;何がすごいかって、たとえば、「巡回セールスマン問題」に使うようなアルゴリズムでも、地点を0と1の間の量子ビットで捉えると、そもそも計算に仮定が必要ない。理論的ではあるが、現実に部分的なアルゴリズムは存在していると考えると、そこを目指すほかない。ディープラーニングにもきっと量子力学は使われているのだろうけど、それを超えるアルゴリズムをつくるには、原則原理から捉える必要がある。そこにこそ、人工知能ビジネスの抜け穴であり、現実的に参戦できるただひとつの場所のようにも思えてくる。&lt;/p&gt;

&lt;h2 id=&#34;なんちゃって人工知能屋さんが多い&#34;&gt;なんちゃって人工知能屋さんが多い&lt;/h2&gt;

&lt;p&gt;なーって思う。人工知能って言っておけばビジネスの波にのれるみたいな風潮が大変嫌いだ。「ディープラーニング」という言葉も音だけが表面を歩いている感じがなんとも言えない。それが人工知能を何度も冬の時代にしてきた根本原因かもしれない。こういうのはもくもくとやっていくものだ。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>１番になるということ</title>
      <link>http://jp.atsushimori.com/no-one/</link>
      <pubDate>Fri, 03 Mar 2017 00:26:56 +0900</pubDate>
      
      <guid>http://jp.atsushimori.com/no-one/</guid>
      <description>

&lt;p&gt;ボクはしばらくの間、「ブランディング」というマーケティング手法について考えてきた。それは、デザインなのか、内側に宿る理念や思想なのか、はたまた、話題性なのか。&lt;/p&gt;

&lt;p&gt;結論から言おう。ブランディングのシンプルな方法は「１番になる」ということ。&lt;/p&gt;

&lt;p&gt;そう思った。&lt;/p&gt;

&lt;p&gt;「ブランド」というのは人によって相対的なコトバなので、ここでの結論は、マーケティングを最大化するという目的を持っている場合という条件をつけておこう。&lt;/p&gt;

&lt;p&gt;マーケティングとは、「継続的に売上を上げるための施策」と訳すのが一般的であるとすると、売上を継続的に上げるためにブランドを作りたいという場合に、「&lt;strong&gt;１番になればよい&lt;/strong&gt;」ということになる。&lt;/p&gt;

&lt;p&gt;そんなのなれるのならあたりまえだと思うかもしれないが、これはシンプル且つ、確かな方法であることを再認識して頂きたいので、改まって言いたい。&lt;/p&gt;

&lt;h2 id=&#34;デザインを着飾るマーケティングはうまくいかない&#34;&gt;デザインを着飾るマーケティングはうまくいかない&lt;/h2&gt;

&lt;p&gt;ブランディングというと、CI（コーポレート・アイデンティティ）たとえば、ロゴや理念などコアな思想を形状化したり、経営方針を整理してまとめたりといったところに注力されることが多い。&lt;/p&gt;

&lt;p&gt;ボクはそれが間違っていると思っている。結果として必要だったのかもしれないが、プロセスとして決して有効な手段ではないと言い切りたい。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;大事なのは形ではなく、意思である&lt;/strong&gt;。その意志はどこからくるかといえば、思想、あるいは勝手に抱いた使命感からである。&lt;/p&gt;

&lt;p&gt;つまり、「もうどうしようもなく、やらずにはいられない」という行動に紐付いた活動は長期的にマーケティングに成功するだろうし、結果的に置かれた状況に対して、ゴーイングコンサーンにもとづいて「やろう」と決意したものでは同じように見えてまったく違うのである。&lt;/p&gt;

&lt;p&gt;それがきれいなコトバにすれば「ビジョン」とか「経営理念」ということになるのだろう。ただ、多くのブランディングを語っている人たちは本当の意味でこの真実にはたどり着いていないのではないかと思っている。&lt;/p&gt;

&lt;h2 id=&#34;誰でも一番になれる&#34;&gt;誰でも一番になれる&lt;/h2&gt;

&lt;p&gt;いままでの経験上、「着飾りのブランド」はほとんど意味をなさないことがわかり、再現性高くブランディングというものを成功させるには一体何が必要なのか、考えた結果が、冒頭に述べた「１番になる」ということだ。&lt;/p&gt;

&lt;p&gt;もっといえば、自分が一番を目指す場所を選択し、且つ、そこに市場がある、または、市場がつくれる、という条件でブランディングはうまくいく。&lt;/p&gt;

&lt;p&gt;大企業のブランディングだと、広告などの力技の影響があり、思考が複雑になるため、例として個人ブログをあげてみよう。&lt;/p&gt;

&lt;p&gt;「ブロガー」という市場は競合がかなり多い。でもうまく広告で暮らしていける「プロブロガー」みたいな人はいつだって一定数いる。一体何が違うのか。&lt;/p&gt;

&lt;p&gt;継続力も含め、一番になれたことが勝因ではないだろうか。&lt;/p&gt;

&lt;p&gt;もちろんアフィリエイターの場合、「採用系」という枠でわかりやすく一番になった人もいるだろうがあ、みんながみんなそうではないことは事実だ。&lt;/p&gt;

&lt;p&gt;そうではない人は、自分で一番になれる場所を作っているのである。&lt;/p&gt;

&lt;p&gt;その最たるものは「個人」を売ることで、これはだれにも真似できない。お金をかけても真似ができない。だから、1/1で１番になっているということだ。&lt;/p&gt;

&lt;p&gt;だから、だれでも一番になれるのだ。&lt;/p&gt;

&lt;p&gt;ただ、それだって簡単ではない。一人で運営するのであれば、究極的に客観視ができなければ、他の多くと同じように自分をまとめてしまうからだ。&lt;/p&gt;

&lt;p&gt;だって、人間には手足があったり、頭があったり、歩けたり、服を着たり・・共通点が実に多くある。顔の形だって世の中には似ている人が結構な数いることだろう。&lt;/p&gt;

&lt;p&gt;では、どうやって「個」を特定するのか。&lt;/p&gt;

&lt;p&gt;それは、掛け合わせしかない。&lt;/p&gt;

&lt;p&gt;興味を持っていること、言い回し、考え方、野望、得意なこと、それらをかけ合わせていくことで、だんだんと競合が少なくなっていく。あとは、そこに市場があるかだけを考えれば良い。&lt;/p&gt;

&lt;p&gt;大体の場合、&lt;strong&gt;自分の中の１番を人は選ぶ&lt;/strong&gt;。だから、多くの人の１番になるべきだというのが持論である。&lt;/p&gt;

&lt;p&gt;なんでこんな簡単なことに気づかなかったのか。&lt;/p&gt;

&lt;h2 id=&#34;想いをカタチにみたいなのは不十分&#34;&gt;想いをカタチにみたいなのは不十分&lt;/h2&gt;

&lt;p&gt;ブランディングをサービスとして提供する人はしばしば、「想いをカタチにしないと伝わりませんよ」という。それは決して間違いでない。ただ、勘違いしていることが多いのは、「クライアントの想いをきれいで伝わりやすいアウトプットで表現する」ということをゴールに掲げていることだ。&lt;/p&gt;

&lt;p&gt;これではプロデューサーにはなれないし、ふわっとした結果しか生まれない。&lt;/p&gt;

&lt;p&gt;たとえば、「人の役に立ちたい」という人が何人いるだろうか。星の数ほどいるそうした理念をカタチにしたところで、よほどの大きな影響力がない限り、意味は伝わらない。&lt;/p&gt;

&lt;p&gt;補足だが、同じ言葉でも発せられる状況によって、伝わる場合もある。たとえば、ギャップがある場合などだ。ただ、ギャップを感じているということはすでに一定の認知を得ているということなので、そうしたケースは除外する。&lt;/p&gt;

&lt;p&gt;本当にまだ認知されていない人や企業が「人の役に立ちたい」といったところで、一番にはなれない。
もちろん、理念がすべてではないが、大事だ。&lt;/p&gt;

&lt;p&gt;もし、プロデューサーとしてプロジェクトに参加するのであれば、本当に必要なカタチに落とし込めるまで、徹底的にヒアリングし、世界レベルの視野をもってアウトプットを考えるべきだ。&lt;/p&gt;

&lt;p&gt;これは、ブランディングを提供する者をディスりたいわけではなく、自分へのメッセージです。&lt;/p&gt;

&lt;p&gt;いかに価値のないマーケティングをしてしまっていたか、今更気づいたのである。&lt;/p&gt;

&lt;p&gt;それなりに売上が上がったり、役に立ったというフィードバックをクライアントから受けることはあれど、どうしても自分の中で腑に落ちないところがあったが、すっきりした。&lt;/p&gt;

&lt;p&gt;一番になれば、マーケティングは成功する。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ウェブのちょっと先の未来予想図</title>
      <link>http://jp.atsushimori.com/the-future-of-web/</link>
      <pubDate>Sun, 19 Feb 2017 15:14:50 +0900</pubDate>
      
      <guid>http://jp.atsushimori.com/the-future-of-web/</guid>
      <description>

&lt;p&gt;最近、NodeをベースにKoaとかElectronとかReactとかを使ってみていたら、将来のWebはこうなるんじゃないかというのがいくつかでてきたのでまとめます。&lt;/p&gt;

&lt;h2 id=&#34;リアルタイムが当たり前に&#34;&gt;リアルタイムが当たり前に&lt;/h2&gt;

&lt;p&gt;Socket.ioとかRethinkDBとか、そのあたりの技術のコモディティ化を考えると、これから先、わりと気軽に「リアルタイムでやろう」という決断ができると思う。&lt;/p&gt;

&lt;p&gt;もちろん、大きなサービスではそれなりに分散とかアーキテクチャーを固めないと運用できないとは思うけれど、10万人程度のユーザーで運用をイメージしたアプリケーションだったら全然いけるハズ。&lt;/p&gt;

&lt;p&gt;リアルタイムになると、どうなるか？&lt;/p&gt;

&lt;p&gt;もっとWebがリアルとの境界線を超えてくるだろう。LINEとかもそうだけど、日常の中に溶け込んでいる。それがウェブサイトでも起こると考えて不思議はない。結局、人は人を感じたいがために生きていて、やっぱり人を感じることは本質的に魅力なのだろう。だから、よくマーケティングの人とかいうのは「Webは24時間働く営業マン」なんて表現をしていた流れとは逆境する流れになるんじゃないかと個人的には考えている。&lt;/p&gt;

&lt;p&gt;もちろん、勝手に24時間ホスティングされているのはされているのに変わりはない。何が言いたいかといえば、逆にリアルタイムになることで、そこには&lt;strong&gt;&lt;em&gt;人に合わせてWebが存在する&lt;/em&gt;&lt;/strong&gt;という在り方が普及するのではないか。ということだ。&lt;/p&gt;

&lt;h2 id=&#34;ルーティングがシームレスになる&#34;&gt;ルーティングがシームレスになる&lt;/h2&gt;

&lt;p&gt;SPA（Single Page Application）という言葉がエンジニアの間では割りと一般的に使われているけれど、これは、単純にDOMを書き換えてビューを操作するということではなく、ルーティングの在り方が変わる可能性を示唆しているといえるのではないだろうか。&lt;/p&gt;

&lt;p&gt;今までのルーティングというのはHttpリクエストに応じてハンドリングしている。しかし、基本的にSPAになるということも考えられないだろうか。もちろん、DOMのレンダリング量によっては死活問題になるなんて見解もあるので、一概には言えないけれど、ルーティングってそもそもなんだっけ？と考えてみると、その表示されているページの固有なIDのようなものである。また、それが正しく検索エンジンに認識してくれるかが大きな問題になることが多い。だから、業務システムとかではSPAいいよねってなるけど、いまいち普及しないのは、ここらへんのインデックスコントロールがうまくできる確証がないからではないか。&lt;/p&gt;

&lt;p&gt;とはいえ、AWWWARDS（awwwards.com）とかでウェブの世界の先端を覗いてみると、Ajaxを使ったサイトが結構でてきていて、シームレスにページ間を移動するというのがこの先トレンドになることが予測できる。&lt;/p&gt;

&lt;p&gt;そうした動向をみても、ルーティングはHistry APIなどでコントロールし、ビューはReactで一躍注目のShadowDOMとかでコントロールするという流れができてきてもおかしくない。&lt;/p&gt;

&lt;h2 id=&#34;デバイスやアプリケーションなどもシームレスになる&#34;&gt;デバイスやアプリケーションなどもシームレスになる&lt;/h2&gt;

&lt;p&gt;デバイスのシームレス第一弾はレスポンシブデザインだろう。ただ、レスポンシブもブレイクポイントに基づいた固定されたインターフェイスの形であって、将来的にはもっと柔軟なフレームワークに変化していくと思っている。ルーティングがシームレス化し、リアルタイムでユーザーの動きとリンクし、ネイティブアプリのように扱われるようになることで、今までとは全く違うUXが必要になる。&lt;/p&gt;

&lt;p&gt;もっとパーソナライズ、ローカライズされた表示にまでシームレス化するだろう。ただ、それが起こるのはGoogleがそうした仕組みを正しく評価しますよ、こうして記述してくれれば検索エンジンに伝わりますよってアナウンスがあってからだと思う。&lt;/p&gt;

&lt;p&gt;とはいえ、GooogleだってUXを重視したエンジンの進化は歓迎だと思うので、ゆくゆくはそうなると考えている。&lt;/p&gt;

&lt;h2 id=&#34;原点回帰&#34;&gt;原点回帰&lt;/h2&gt;

&lt;p&gt;結局は原点に立ち戻る。それは本質ということだから、あたりまえ。ウェブもそうなるのではないだろうか。あれもこれも実現するためにモリモリに実装されたモジュール群や、「もし、こうなったときのために」と汎用性をもたせすぎたライブラリ群、用語に偏ったWeb業界のカルチャー、いろんなものが原点に戻った時に、ものすごくシンプルにとらえることができるのだと思う。そうした時代がいつかくるのだろうか。&lt;/p&gt;

&lt;p&gt;ただ、言えるのは人工知能とかいろいろ進んでくると、「やっぱり人間の範囲でやれることをやるのが幸せだね」ってことに気づいて、取捨選択されていくことは予測できる。&lt;/p&gt;

&lt;p&gt;とまぁ、妄想気味にウェブの未来を考えてみたけど、改めて思うのは最近の技術進化は本当にワクワクすることが多い。今は技術のかけらだけど、組み合わせると一歩先の未来が見えてくるから、そういうことを考えていると楽しい。プログラミングの魅力のひとつだ。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>もう少しで完成</title>
      <link>http://jp.atsushimori.com/timing/</link>
      <pubDate>Tue, 27 Dec 2016 23:36:27 +0900</pubDate>
      
      <guid>http://jp.atsushimori.com/timing/</guid>
      <description>

&lt;p&gt;もう少しでGeneのβが完成する。なんとか年内にリリースしたい。&lt;/p&gt;

&lt;p&gt;今まで、受託を一生懸命やっていたせいか、今回一応オリジナルプロダクトをつくると何人かに話したらとても興味を持ってくれていてすごく新鮮な気持ちだ。&lt;/p&gt;

&lt;p&gt;そうだよね、考えてみれば、どこそこのウェブサイトを作ったっていっても実力を測る材料にしかならないもんね。気づかなかったけど、何か製品をつくるってすごくいい。クライアントワークとは違う期待をいただき、それがとてもポジティブな期待で心地よい。&lt;/p&gt;

&lt;p&gt;あとは、意外と使いたいって言ってくださる方もいて、「ボクが利用者一番になりますよ」なんてうれしいこと言ってくれた人もいた。&lt;/p&gt;

&lt;p&gt;やる気です。&lt;/p&gt;

&lt;p&gt;さて、Geneの方ですが、いよいよテンプレートを用意する段階になって、概ねGUI上の仕組みは完成しました。あとはプレビュー用にローカルサーバーを立てる関数を作ったり、すれば、出来上がる。&lt;/p&gt;

&lt;p&gt;協力してくれている人からは「いつもみたいにこだわるから今回ははやく出しましょう」ってリーンスタートアップ的なノリで言ってくるんですけど、ある程度のクオリティを下回るようならたとえβ版だとしてもリリースはしたくないと思っていて、それで想定より半月ほど遅くなってしまったんですね。&lt;/p&gt;

&lt;p&gt;リーンスタートアップって、スタートアップ、つまり新しい技術や革新的なことについての開発サイクルの話であるというのがボクの持論で、今回わりとありふれたサイト生成ツールを作っているので、使った時点で直感的に良さ（こだわったディテールの部分が機能している箇所）を実感してもらわないと、多分使い続ける理由が残らないんだと思うんですよね。&lt;/p&gt;

&lt;p&gt;で、今回狙っている感動ポイントはこんな感じです。&lt;/p&gt;

&lt;h2 id=&#34;公開までの速さ&#34;&gt;公開までの速さ&lt;/h2&gt;

&lt;p&gt;公開まではサイト名やリモートホストの必要項目を10あまり入れ、ボタンを押せばその時点で公開できます。情報が揃っていれば、新しいサイトが1分足らずで作れます。記事を一つ書く時間を考慮すると2-30分でわりといい感じのサイトが立ち上がります。&lt;/p&gt;

&lt;p&gt;これは、データベースを使わない選択をしたことが大きく影響しています。&lt;/p&gt;

&lt;h2 id=&#34;記事を書いている途中でおちるストレスがない&#34;&gt;記事を書いている途中でおちるストレスがない&lt;/h2&gt;

&lt;p&gt;ネット上のツールではないので、落ちることはほとんどないと思います。100%ではないですが、ブラウザほどエラーは発生しないでしょう。&lt;/p&gt;

&lt;p&gt;これはローカルアプリということが利点になるところです。&lt;/p&gt;

&lt;h2 id=&#34;デザイン性&#34;&gt;デザイン性&lt;/h2&gt;

&lt;p&gt;デザインレベルが高い（と思う）正直Wordpressでこれはいい、そのままプロダクトレベルで使える！と感動したテンプレートはありません。海外のテンプレートはデザイン性が高いのですが、日本語に対応させるとCSSをいじったりしないといけません。&lt;/p&gt;

&lt;p&gt;とにかくそのまま使えるレベルの高いテンプレートを提供して、シェアを広げたい。ここらへんはマーケティング戦略でもあるかなといったところです。&lt;/p&gt;

&lt;h2 id=&#34;ノーコード&#34;&gt;ノーコード&lt;/h2&gt;

&lt;p&gt;Geneはすべてがシンプルにできています。拡張性よりも必要性が大事だと思っているので、（というか拡張性を使いこなせる人はそこまで多くないので必要ない）必要最低限の機能に絞ってしまうことで、究極のシンプルを目指します。&lt;/p&gt;

&lt;p&gt;以上、現場からお届けしました。
コーディングに戻ります。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Gene</title>
      <link>http://jp.atsushimori.com/gene-is-awsome/</link>
      <pubDate>Wed, 21 Dec 2016 00:40:25 +0900</pubDate>
      
      <guid>http://jp.atsushimori.com/gene-is-awsome/</guid>
      <description>

&lt;p&gt;今日もコーディングを続けている。知らないコードを学んでいく工程をはさみながらなので思うようには進みません。ただ、完成は間近です。&lt;/p&gt;

&lt;p&gt;コードネームははGene（ジーン）。英語で「遺伝子」という意味です。サイトマネージャーわかりやすく言えばウェブサイトの作成／管理ツール。ボクは本気でこの製品が数千万人、数億人の手にわたることを想像している。今日のウェブサイト制作や管理には無駄が多い。パフォーマンスだって最高レベルではない。Geneをシンプルにとらえることで、本来欲していた要件が非常にシンプルだったことに気づくだろう。&lt;/p&gt;

&lt;p&gt;いつだって最高の製品には最高のプロデューサーが必要だ。リリースしてみないと断言はできないが、ボクの考えていることがより真理に近いということを、Geneを通じて証明したい。&lt;/p&gt;

&lt;p&gt;なお、β版であるファーストリリースのバージョンはElectronをつかったmacアプリを想定している。もちろん、その先にはいろいろな構想があるのだけれど、一気にはできないので、機能とプラットフォームを限定した形でのリリースを予定しています。&lt;/p&gt;

&lt;p&gt;リリースの前に、なぜGeneの開発を進めることにしたのかを説明しておきたい。&lt;/p&gt;

&lt;p&gt;ターゲットとなるのはWordpressなどのオープンソースCMSを使用しているユーザーになるだろう。ボクも5年くらいWordpressは使っていた。便利だし、CMS利用の選択肢としては革新的なものだった。ただ、完璧に腑に落ちたことは一度もなかった。だからパーフェクトな製品をつくりたいと思ったんです。&lt;/p&gt;

&lt;p&gt;具体的には以下のようなことを改善しようと思っています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;パフォーマンスの向上&lt;/li&gt;
&lt;li&gt;ライティングが身近になるような仕組みづくり&lt;/li&gt;
&lt;li&gt;AMP対応&lt;/li&gt;
&lt;li&gt;検索エンジン対策の平均レベルをあげる仕組みづくり&lt;/li&gt;
&lt;li&gt;セキュリティ問題（PCローカルをフル活用する）&lt;/li&gt;
&lt;li&gt;CPUを用いた人工知能の活用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;などなど、ファーストリリースでは機能をどこまで制限するかは未定だが、まずはサイトジェネレーターとして、サイトマネージャーとしての機能が備わっていれば良いと考えている。&lt;/p&gt;

&lt;p&gt;macOSアプリをリリースしたら、iOS版を進めたい。静的にサイトを書き出す仕組みだが静的サイトジェネレーターのiOSアプリはなさそうだ。必要だと思う。&lt;/p&gt;

&lt;p&gt;それぞれについて少し。&lt;/p&gt;

&lt;h2 id=&#34;パフォーマンスの向上&#34;&gt;パフォーマンスの向上&lt;/h2&gt;

&lt;p&gt;WordpressはTTFB(Time to First Byte)がどうしても改善が難しい。それはコアファイルの実行に時間がかかってしまうからどうしようもない。CDNなどを使用したり、AMPを導入したりして表示速度は申し分ないほどに改善ができるが、中途半端な知識でキャッシュを扱うとある環境では画像が表示されなかったり、CSSのスタイルが崩れたりする。そもそもそうしたバグを生まないような仕組みが必要です。&lt;/p&gt;

&lt;h2 id=&#34;ライティングが身近になるような仕組みづくり&#34;&gt;ライティングが身近になるような仕組みづくり&lt;/h2&gt;

&lt;p&gt;多くのCMSはブラウザ上にGUIを備えている。アカウントだって必要だ。Geneはローカルアプリなので、PCを開いてアプリを起動すればいつでも書き始められる。インターネット通信の切断があって、1時間かけて途中まで書きかけた記事がパーになることもなくなる。また、シンプルでいけてるUIが日常に溶け込んでいくことを願っている。&lt;/p&gt;

&lt;h2 id=&#34;amp対応&#34;&gt;AMP対応&lt;/h2&gt;

&lt;p&gt;AMPはGoogleのサーバーに画像などをキャッシュさせられる仕組みで、準拠したHTMLの記述をすれば、たしかなパフォーマンスを約束してくれる。検索順位的にもモバイルページでは優位になっている例が確認できている。これを使うかどうかを簡単に選べるようにする。ページ毎にワンクリックで導入できれば、とても便利だともう。Wordpressのように別URLの管理など必要ない。（UI、設計にこだわるなら使えないかもしれないが、AMPに頼らなくてもう十分なパフォーマンスを実現できる予定）&lt;/p&gt;

&lt;h2 id=&#34;検索エンジン対策の平均レベルを上げる仕組みづくり&#34;&gt;検索エンジン対策の平均レベルを上げる仕組みづくり&lt;/h2&gt;

&lt;p&gt;とくにHTMLのhead情報に関してはパターンが決まっているのに、個々にカスタマイズをさせると品質にばらつきがでてしまう。Geneもテーマの適用という概念をとりいれる予定だが、head情報はテーマ制作者には変更できないようにする予定だ。そもそも毎回記述するの必要がないし、OGPの設定やcanonicalの設定なんて自動化すべきことだからです。もちろん検索エンジンの対策については多岐にわたるという反論もあるとおもうので、一部の対策という理解でいてもらいたい。&lt;/p&gt;

&lt;h2 id=&#34;セキュリティ問題&#34;&gt;セキュリティ問題&lt;/h2&gt;

&lt;p&gt;Wordpressの課題としていつもくっついてくるのがセキュリティ問題である。なぜみんなブラウザGUIを使うのだろうか。アプリケーションにすればセキュリティ問題は最小限にとどめることができる。これもシンプルに考えた末の真実だと思っている。&lt;/p&gt;

&lt;h2 id=&#34;cpuを用いた人工知能の活用&#34;&gt;CPUを用いた人工知能の活用&lt;/h2&gt;

&lt;p&gt;Webは時期に次世代の進化をとげる。そのときにオープンソースは乗り遅れることになると思っています。また数十年先になればサーバーコストも低くなって、オープンソースにできるかもしれないが、人工知能の活用はどうしても十分な性能を出せるプラットフォームが必要になる。だから最初のうちは大企業しか参入できないだろう。だとすると時代の変化に併せて改善を最速で進めていくためには個々のCPUを使うことが鍵になってくる。まだディープラーニングなどのアルゴリズムだとCPUだとスペックが足りないが、より効率のよいアルゴリズムが開発されるか、ボクが開発するだろう。&lt;/p&gt;

&lt;p&gt;Geneは次世代のウェブマネジメントを牽引するツールになる。
そう信じている。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Node.jsのFile Systemで画像を扱うときの出力方法</title>
      <link>http://jp.atsushimori.com/image-encoding-intro/</link>
      <pubDate>Sun, 18 Dec 2016 01:41:28 +0900</pubDate>
      
      <guid>http://jp.atsushimori.com/image-encoding-intro/</guid>
      <description>

&lt;p&gt;Electronを使っていると、けっこう使うFile Systemモジュールですが、画像を扱う際にバイナリとかバッファとかBase64などのエンコーディングでてきますよね？エンコードまわりと基本的なfsモジュールの出力操作について触れたいと思います。&lt;/p&gt;

&lt;h2 id=&#34;バイナリとは&#34;&gt;バイナリとは&lt;/h2&gt;

&lt;p&gt;2進法で表現したデータのことです。2進法とは数字の0と1をつかって数を表す方法です。「デジタルは0と1でできている」とどこの誰かが言ったりしますが、機械は2進法でプログラムを読み取ります。なぜ2進法かというと、単純に計算がし易いからではないかと思います。&lt;/p&gt;

&lt;p&gt;日常的にボクたちが使っているのは0~9の10個の数字で表す10進法ですが、コンピュータにとっては理解するのがすこし遠い言語になってしまうわけです。0と1の組み合わせは◯（マル）か☓（バツ）かみたいな判断をしていくことと同じなので、シンプルですね。&lt;/p&gt;

&lt;p&gt;つまり、画像データでバイナリということは、色やピクセルの配置、その他画像に含まれる情報がすべて0と1で表現されたデータということです。アプリケーションなんかを作る場合、操作性を意識しますから、バイナリデータを変数に格納して入出力したりすることで、処理が早くなるというメリットがあります。&lt;/p&gt;

&lt;p&gt;ただ、注意しなくてはならないのは、ブラウザなどのフロント側ではバイナリデータを直接読み込んで表示するわけではないので、バイナリデータを処理で使用する場合は、jpgやpngなどに変換する作業を挟まないといけません。まぁ小さい画像くらいならいいのですが、大きいサイズの画像や動画とかになったら処理が重たくなりがちなので通信するデータサイズを縮小し、CPUやGPUなどの負荷を小さくするためにバイナリデータをうまく使っていくといいみたいです。&lt;/p&gt;

&lt;h2 id=&#34;バッファとは&#34;&gt;バッファとは&lt;/h2&gt;

&lt;p&gt;バッファとは、入出力処理において、プログラム処理中のタイムラグを補う目的で実装されたデータを一時的に保存する記憶領域のことを指します。英語では「緩衝記憶装置」「緩衝物」を意味する単語みたいです。&lt;/p&gt;

&lt;p&gt;イメージしやすいと思いますが、一時ファイルを扱うので、データを気軽に扱うことができます。あまりに大きなデータを扱うには向きませんが、さらっと「ちょっとこれ持ってて！」くらいのデータだったら柄どころが結構あるのではないでしょうか。&lt;/p&gt;

&lt;p&gt;Vimをやっている人ならバッファの概念はお手の物だと思いますが、たとえば、音楽の録音ソフトとかで「バッファサイズが足りません」とかってでる、あれもバッファですね。要するにそうしたエラーがでるのは、「両手塞がってるからもう無理！」という状態のことですね。扱うデータ量の最大値を想像して設計しないとああした自体に陥ります。&lt;/p&gt;

&lt;p&gt;手軽なデータに使いましょう。&lt;/p&gt;

&lt;h2 id=&#34;base64とは&#34;&gt;Base64とは&lt;/h2&gt;

&lt;p&gt;バイナリデータを「A-Z,a-z,0-9,+,/」の64文字で表現するエンコード規格とのことです。64進数ということですね。◯進数とは「◯文字でデータを表現するのか」ということに近いと思うので、ざっくり覚えたいかたはそう覚えておきましょう。&lt;/p&gt;

&lt;p&gt;さて、バイナリデータが軽やかであるという話がでたのに、なぜあわざわざBase64のデータを使うシチュエーションが生まれるのでしょうか？&lt;/p&gt;

&lt;p&gt;答えをさきに言うと、ボクたちが日々使うメールのために作られた規格のようです。メール送信でSMTPって聞いたことありますかね？これは送信メールの通信規格なんですけど、当時このSMTPではASCIIデータという7Byteで表現される英数字しか送れなかったようです。日本語とかを扱うためにゴニョゴニョ最適化でもしたのでしょうか。それで、画像や音声のデータをこれじゃ送れないってことで、Base64というデータ変換方式が作られたとさ。&lt;/p&gt;

&lt;p&gt;プログラミングにおいては、正規表現などをつかってデータをフィルタリングしたりするのに一貫性のあるデータの方が使いやすいって理由でBase64が使わたり、画像データとしてブラウザでも表示できるので、そのような用途がある場合に使用されたりしています。&lt;/p&gt;

&lt;p&gt;パフォーマンスというよりはデータの整形や表示が楽というメリットがあります。&lt;/p&gt;

&lt;h2 id=&#34;それらを踏まえていざwritefile&#34;&gt;それらを踏まえていざwriteFile&lt;/h2&gt;

&lt;p&gt;ここまでは前置きでしたが、本題はそう長くありません。扱うデータをいづれかにするというだけなので、はっきりいって結論だけなら10行で終わりでした。前置きを伸ばしたお陰で記事っぽくなってよかったです。&lt;/p&gt;

&lt;p&gt;書き方はこうです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;);
fs.writeFile(public, data, {encoding: &#39;指定&#39;}, function(err){
    // Any Code
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指定部分には&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;binary&lt;/li&gt;
&lt;li&gt;buffer&lt;/li&gt;
&lt;li&gt;base64&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;とかがはいったりしますね。&lt;/p&gt;

&lt;p&gt;あとは適当に試行錯誤してみると良いと思います。&lt;/p&gt;

&lt;p&gt;では。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>人工知能アルゴリズムをつくるために</title>
      <link>http://jp.atsushimori.com/algorithms/</link>
      <pubDate>Sat, 17 Dec 2016 09:01:25 +0900</pubDate>
      
      <guid>http://jp.atsushimori.com/algorithms/</guid>
      <description>

&lt;p&gt;いまさらながら勉強をはじめた。プログラミングの知識をある程度得ると、もっとプログラムを小さくしたいと思い始める。たとえば、いつくつかのイベントを配列にしたりとか、ループで生成するとか、すこしでも小さなコードで多くのことをやりたいと思うのがプログラマーというものなのでしょう。とはいっても、ゲームとかCGとかハードウェアを扱うプログラマーなんかきっとパワフルなアルゴリズムをグワングワン使いこなしてるんだろうなーと思うと諦めたくもなります。ただ、物事を始めるのに遅いということはないと思うので、やってみる。現にこの数ヶ月でNode.jsとRailsとC++（の入り口）はある程度扱えるようになった。&lt;/p&gt;

&lt;p&gt;今は何かに取り憑かれたかのように毎日プログラミングをしている。今日も13時間以上ぶっ続けでコーディングしていた。それは製品づくりの佳境ということもあるけど、ある種の現実逃避なのかもしれない。今やらなきゃいけないという強迫観念みたいなものに推し進められているこのごろ。&lt;/p&gt;

&lt;p&gt;たとえば、10行で書くプログラムを3行にするとか、それはもうググってコードを切り貼りしてという世界ではない。むしろ、少しプログラミングの勉強をすると、自分の頭で考えて書いているコードがどれだけ少ないかということに気づく。別に動けばいいのだけど、もはやプログラミングは表現のツールなんだと思う。だから本人が良しとしなければ完成しないのだ。&lt;/p&gt;

&lt;p&gt;表現のツールということで言えば、音楽と似ている。音楽もおそらく音楽家同士が集まれば、ほとんどの場合どこかにコメントしたくなる。&lt;strong&gt;それは個々の表現のフィールドをもっていて、一致することはない&lt;/strong&gt;からだろう。プログラミングも似ているところがあるのかもしれない。やっぱり優秀だと一般的に言われている人のコードはスマートだ。&lt;/p&gt;

&lt;p&gt;さて、話はそれましたが、アルゴリズムの話ですね。今、人工知能のビジネス市場に入っていくために、少し遠回りな手法をとろうとしていて、そのための製品をつくっています。それは今ある技術でできるものなのでいいのですが、ボクが考えていることを実現していくためには、既存の考え方では立ち行かなくなると思っているので、原理から考えられる頭を鍛えようというのがアルゴリズムを勉強する動機です。&lt;/p&gt;

&lt;p&gt;あるいは、世の中の答えもある種のアルゴリズムによって導き出されることが多いと思うので、アルゴリズムを紹介しながら、それを日常に当てはめるとどんなことに使えるか？みたいな遊び半分でやっていきたいと思っています。&lt;/p&gt;

&lt;p&gt;おそらく数学をやっていた人なら、学生時代から「アルゴリズム」という言葉に触れるのでしょうが、ボクが初めて「アルゴリズム」という言葉を認識したのは「Google」の「アルゴリズム」です。魔法の言葉みたいな感じで、「アルゴリズムが・・・」「アルゴリズムが変わりましたね・・・」なんて会話が飛び交っているマーケッター界隈をみていると、今の頭で考えると不自然ですね。&lt;/p&gt;

&lt;h2 id=&#34;アルゴリズムとは何か&#34;&gt;アルゴリズムとは何か？&lt;/h2&gt;

&lt;p&gt;ある情報によると、アルゴリズムとは、&lt;strong&gt;ある値あるいはある値の集合を入力とし、ある値あるいはある値の集合を出力する明確に定義された計算手続き&lt;/strong&gt;とある。もう入り口から堅いんだよな。要するに計算式だね。計算には入力値と答えが必要だもんね。どちらにせよ、プログラミングの世界では日常的につかっていることなんだろうから、その延長でより高度でスマートな計算手法を身に着けていけたらと思います。&lt;/p&gt;

&lt;p&gt;そうそう、Googleの「アルゴリズム」というのが＝検索順位みたいに扱われているのが違和感があったわけですね。ただの計算式ですから。人工知能だって魔法じゃない。計算式だ。シンプルな計算だけだと決まった答えしかだせないから、ランダムな値や秩序のない値をぶつけたりして、偶然性を取り入れながら人間の脳に近づけるってこといろいろやられているみたいですね。ある種魔法か、おそらく、すでにこうしたらこうなるという計算を辿れる人はいないほど、アルゴリズムは進化しているはずだ。ディープラーニングだって扱う情報が画像の何十万、何百万というピクセルデータを追える人間なんていない、見る人によっては魔法かもしれない。&lt;/p&gt;

&lt;h2 id=&#34;アルゴリズムの種類を少し予習&#34;&gt;アルゴリズムの種類を少し予習&lt;/h2&gt;

&lt;p&gt;さて、どんなことを学ぶのかなーと思って1000ページ超えの教科書を開いてみたのだけれど、数式ばっかでなにひとつ理解出来なそう。まぁ、これはプログラミングも同じで、最初はムリと思っても、分解してやってくといつのまにか飛び級で分かった感じになると信じよう。目次から大項目だけ書いてみよう。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;関数の増加&lt;/li&gt;
&lt;li&gt;分割統治&lt;/li&gt;
&lt;li&gt;確率的解析と乱択アルゴリズム&lt;/li&gt;
&lt;li&gt;ヒープソート&lt;/li&gt;
&lt;li&gt;クイックソート&lt;/li&gt;
&lt;li&gt;線形時間ソート&lt;/li&gt;
&lt;li&gt;中央値と順序統計量&lt;/li&gt;
&lt;li&gt;基本データ構造&lt;/li&gt;
&lt;li&gt;ハッシュ表&lt;/li&gt;
&lt;li&gt;2分探索木&lt;/li&gt;
&lt;li&gt;2色木&lt;/li&gt;
&lt;li&gt;データ構造の補強&lt;/li&gt;
&lt;li&gt;動的計画法&lt;/li&gt;
&lt;li&gt;貪欲アルゴリズム&lt;/li&gt;
&lt;li&gt;ならし解析&lt;/li&gt;
&lt;li&gt;B木&lt;/li&gt;
&lt;li&gt;フィボナッチヒープ&lt;/li&gt;
&lt;li&gt;van Emde Boas木&lt;/li&gt;
&lt;li&gt;互いに素な集合族のためのデータ構造&lt;/li&gt;
&lt;li&gt;基本的グラフアルゴリズム&lt;/li&gt;
&lt;li&gt;最小全域木&lt;/li&gt;
&lt;li&gt;単一始点最短路問題&lt;/li&gt;
&lt;li&gt;全点対最短路&lt;/li&gt;
&lt;li&gt;最大フロー&lt;/li&gt;
&lt;li&gt;マルチスレッドアルゴリズム&lt;/li&gt;
&lt;li&gt;行列演算&lt;/li&gt;
&lt;li&gt;線形計画法&lt;/li&gt;
&lt;li&gt;多項式とFFT&lt;/li&gt;
&lt;li&gt;整数論的アルゴリズム&lt;/li&gt;
&lt;li&gt;文字列照合&lt;/li&gt;
&lt;li&gt;計算幾何学&lt;/li&gt;
&lt;li&gt;NP完全性&lt;/li&gt;
&lt;li&gt;近似アルゴリズム&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;映画のタイトルかよっ！&lt;/strong&gt; ってツッコミいれたいくらい非日常的な言葉がならんでますね。クイックソート、フィボナッチ、行列演算あたりですかねー、少し知っているのは。先が思いやられる。&lt;/p&gt;

&lt;p&gt;個人的に気になるのは&lt;strong&gt;貪欲アルゴリズム&lt;/strong&gt;！貪欲な人間が貪欲アルゴリズムで解けるのか、ぜひ試したい。「van Emde Boas木」に関してはなぜ「木」だけ訳した？ってこれまた疑問が残ります。どうせなら全部英語にしちゃえばよかったのに。あとはだいたい英語にすれば映画タイトルにそのまま使えますね。あ、「ハッシュ表」って「ハッシュテーブル」じゃん。なんか逆に中途半端な日本語によってわかりづらくなっているような・・・基本的にプログラミングだとおおよそググっても英語の記事にたどり着く場合が多いので、ある程度の英単語なら結構みんなわかるはずだし。&lt;/p&gt;

&lt;p&gt;さてと、今年の途中から高校数学IA,ⅡB,ⅢC（Cはなくなったの？）を改めて勉強してて、数学にも大変興味がでてきているところなので、アルゴリズムをグリングリンつかえるように貪欲にがんばっていきたいと思います。まずはアルゴリズム勉強開始の宣言ということで。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Javascriptの配列と連想配列</title>
      <link>http://jp.atsushimori.com/array-and-associative-array/</link>
      <pubDate>Tue, 13 Dec 2016 04:51:28 +0900</pubDate>
      
      <guid>http://jp.atsushimori.com/array-and-associative-array/</guid>
      <description>

&lt;p&gt;Javascriptをいじりだして、JSONの値を持ってくる時に連想配列のネストでいいんだっけ？配列にしたほうがいいんだっけ？と迷いながら、配列と連想配列の扱いについて方針を決めました。&lt;/p&gt;

&lt;h2 id=&#34;配列と連想配列の使い分け&#34;&gt;配列と連想配列の使い分け&lt;/h2&gt;

&lt;h3 id=&#34;配列を使う場合&#34;&gt;配列を使う場合&lt;/h3&gt;

&lt;p&gt;基本的にforとかで回すときは配列を使ったほうがいい。.lengthでとれるので。具体的には例えば、ブログ機能みたいなのをつくっているとして、ブログの記事の管理とか、各記事のカテゴリー情報とかタグ情報、こういった類のものは配列にいれてしまったほうが取り出しやすい。自分で設計できる場合という前提になりますが・・・。&lt;/p&gt;

&lt;p&gt;これはJSONファイル側です。Javascript側のオブジェクトで扱う場合は適宜調整が必要になることもあると思います。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;title&amp;quot; : &amp;quot;title&amp;quot;,
    &amp;quot;categories&amp;quot; : [&amp;quot;cat1&amp;quot;,&amp;quot;cat2&amp;quot;],
    &amp;quot;tags&amp;quot; : [&amp;quot;tag1&amp;quot;,&amp;quot;tag2&amp;quot;]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;連想配列の中の配列と言ったほうがいいのでしょうか。&lt;/p&gt;

&lt;h3 id=&#34;連想配列を使う場合&#34;&gt;連想配列を使う場合&lt;/h3&gt;

&lt;p&gt;大枠の構造をつくる場合に使う、というかJSONの構造自体が連想配列ということになるのでしょうか。なので、連想配列が基本にあって、その中のどこに配列を使えばいいかという話でしょうかね。基本的にフラットに格納できるのが一番シンプルで取り出しやすいので、データの設計で分業する形をとるっていうのも手ですね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;sitename&amp;quot; : &amp;quot;title&amp;quot;,
    &amp;quot;url&amp;quot; : &amp;quot;http://hoge.com&amp;quot;,
    &amp;quot;discription&amp;quot; : &amp;quot;hogehoge.&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;jsonから特定の値を取り出す&#34;&gt;JSONから特定の値を取り出す&lt;/h2&gt;

&lt;p&gt;Node.jsベースのアプリケーションであれば、fsモジュールのreadFileなどでJSONを読みこんでそれをオブジェクトに変換して使ってあげればJavascript側でいろいろと値をいじることができます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;);
var path = &#39;dir/dir/data.json&#39;;
var loadFile = JSON.parse(fs.readFileSync(path, &#39;utf8&#39;));

console.log(loadFile.Key); // Keyはtitleとかsitenameとかの値です。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;配列の要素数を取り出す&#34;&gt;配列の要素数を取り出す&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;console.log(laodFile.categories.length);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.lengthで配列の個数が返ってきますので、これでfor文の範囲に指定したりすればループできます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (i = 0; i &amp;lt; loadFile.categories.length; i++) {
    console.log(loadFile.categories);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JavascriptってWebともともとマッチするし、Node.jsでバックエンド側含めてJavascriptで書くってことも多くなってきている印象ですね。&lt;/p&gt;

&lt;p&gt;以前はWordpressをちょこっといじるレベルのただのコーダーだったのですが、最近の革新の技術は本当に幅広く応用が可能で、プログラミングどっぷりつかって良かったなと最近思っています。&lt;/p&gt;

&lt;p&gt;MeteorかExpressも近々やってみようと思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>オープンソースは最高なのか？</title>
      <link>http://jp.atsushimori.com/how-to-use-open-source/</link>
      <pubDate>Mon, 12 Dec 2016 02:37:31 +0900</pubDate>
      
      <guid>http://jp.atsushimori.com/how-to-use-open-source/</guid>
      <description>&lt;p&gt;オープンソースは確かに良い。社会的意義もある。ただ、プロジェクトの在り方は慎重に選択する必要があると思っています。&lt;/p&gt;

&lt;p&gt;たとえば、Apple製品。仮にオープンソースだとしたら、仕入れなどの製造コストは抜きにして、AppleがオープンソースプロジェクトとしてMacを管理していたとしたら今日までの製品は誕生しただろうか？答えはおそらくしていない。100%ではないが、オープンソースだった場合、今のレベルのApple製品は誕生していなかっただろう。&lt;/p&gt;

&lt;p&gt;なぜ、Apple製品は良かったのか。答えは簡単。Steve Jobsという優秀なプロデューサーがいたからに他ならない。もちろん、Steve Jobsがこの世にいなくなった今日もApple製品は相変わらず優れていることが多い。ただ、何かが変わった。疑問を持つことが多くなった。ボクは今iPhobe7を使っているが、それまではiPhone5Sを使っていた。画面が大きくなったiPhoneを初めて使った感想は画面サイズがイマイチしっくりこないということだ。アプリでブラウジングしていて、一つ前のページに戻りたい場合、多くの場合左上に「戻る」アクションエリアがある。iPhone5では片手で届いたのだが、iPhone7ではがんばらないと届かない。あるいはApple Music。ダウンロード済みコンテンツとアルバム一覧から局を選択する場合とで一覧に表示されている局が異なっていてどれをダウンロードしていて、どれをダウンロードしていないかわからなくてモヤモヤが残りながら使っている。&lt;/p&gt;

&lt;p&gt;もう一度言いたい。何かが変わった。かつての疑問を持たずに使えたApple製品ではなくなってしまったかのうようだ。&lt;/p&gt;

&lt;p&gt;法人としてのAppleは誰もが認める成功企業だ。ただ、今の製品にはボロがでてきている。それは偶然なのだろうか？プロデューサーであるSteve Jobsの存在を思い返さずにはいられない。&lt;/p&gt;

&lt;p&gt;話は戻ってオープンソースのことについて触れよう。オープンソースプロジェクトは日々助けられているし、否定するつもりは一切ない。社会的意義があることだし、素晴らしい。ただ、最高の製品を作りたいときは、オープンソースは良くないのではないかと思い始めている。&lt;/p&gt;

&lt;p&gt;オープンソースのメリットは、改善のスピードと発展のスピードが速く、技術そのものを加速する力もある。逆にデメリットは、プロデューサーが分散することで、製品のコントロールが難しくなるということだろう。オープンソースとしてヒットした製品といえば、WordpressあるいはRuby on Railsなどが挙げられる。いづれも素晴らしい製品だし、日々お世話になっている人も多いことだろう。ただ、何かが足りない。&lt;/p&gt;

&lt;p&gt;オープンソースの開発は不特定多数の開発者がソースコードをいじる。Gitなどで管理され、masterを管理するひとはもちろんいるし、修正リクエストを精査することだってできる。ある種の組織運営に近い話になる。しかし、オープンソースは民主主義になりがちなので、管理者の権限をストレートに活かし切ることはできない。そこが最大の欠点である。&lt;/p&gt;

&lt;p&gt;だから最高のプロダクトを作り出したいのであれば、おおよそ有能なプロデューサーの権限のもと、製品をつくり、改善していくことが必要だと感じます。&lt;/p&gt;

&lt;p&gt;今、渾身のプロダクトを開発しています。それでこの定義を証明したいと思っています。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>会社である必要性と経営者の種類</title>
      <link>http://jp.atsushimori.com/why-company/</link>
      <pubDate>Fri, 09 Dec 2016 20:57:50 +0900</pubDate>
      
      <guid>http://jp.atsushimori.com/why-company/</guid>
      <description>

&lt;p&gt;「会社やめたいっす」と言う人って結構いる。決まってボクは「やめれば？」と言う。でもそれでやめた人と会ったことがない。そして、それは正しい選択だろうと思う。ボクはやめようと思って実際に数ヶ月後には勤めていた会社をやめていた。組織である法人と個人の間にはそもそも求めることに矛盾があります。法人は組織として機能しつづけるように仕組みをつくっていく、つまり個人の能力に依存しない組織運営を作りたいものであり、個人というのはいつだって個人の能力アップを望んでいるものだろう。（分野は異なると思いますが。）つまり、そもそも会社と個人というのは相反する思想のもと、共存しているのです。&lt;/p&gt;

&lt;p&gt;本来は、個人それぞれにやりたいことをやればもっと世の中に多様性が生まれることでしょう。でも、そうはならない。会社に居続ける人は多い。その結果、「会社をやめたいけれどすぐにはやめられないし、やりたいこともみつからない」という人が増える。現に「自分が何をやりたいのかわからない」という人はなぜか多い。勝手に考えた結果、きっとそれは会社という組織体によって、「個」と向き合う時間が減るからだろうという結論にたどりついた。&lt;/p&gt;

&lt;p&gt;視点を変えて、フリーランスの人たちの世界で考えたらどうだろうか。彼彼女らはみんな、「やりたいけどできないことがたくさんある」と言う。やりたいことはいくらでもあるけれど、今やっている仕事の納期に追われてできない、あるいはその仕事を蹴ると収入に困るといった別の理由でやりたいことができずにいたりする。そもそも独立する人はやりたいことがあって独立するものだからと思う人もいるかもしれないが、それは違います。ボクもフリーランスとして2年間くらいやっていましたが、始めたときは何をやればいいかもわからず、なんで会社をやめたかといえば、「やめたかったから」という理由だけでした。やっぱり自分はこんなもんじゃないみたいな根拠のない自信と、それに対する葛藤に耐えかねたという忍耐力のなさがそうさせただけで、何もビジョンなんてありませんでした。&lt;/p&gt;

&lt;p&gt;フリーランスになって、まず始めること、それは「自分のできること」「自分のできそうなこと」をやってみるということです。やりたいことをやり始められる人は優秀ですが、残念ながらボクはそうではありませんでした。ただ、今思うのは、はじめるときに何を始めるかなんてことはこれっぽっちも意味がないということ。同じく、一生使える屋号や会社名を頑張って考えることも結構無駄。やってしまえば、だんだんしっくりくるものなのです。ここまでは、自分の欲望に素直かどうかって話ですね。&lt;/p&gt;

&lt;p&gt;たまに考えるのですけど、「なんで会社なんてやってるんだろう」という自分に対する疑問の話です。ボクも場合は、自分の生きる価値、生きるに値する生き方を全うするためには一人では成し得ないことがわかりきっているからめんどうでも会社でいる必要性があるという考えのもと、毎日を過ごしています。&lt;/p&gt;

&lt;p&gt;世の中には多くの「社長」と呼ばれる人がいて、そのタイプはいくつかにクラスタリングできると思っています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;「社長」という言葉に魅力を感じる人&lt;/li&gt;
&lt;li&gt;親の代から引き継いで2代目になる人&lt;/li&gt;
&lt;li&gt;まわりが必要として社長になるひと&lt;/li&gt;
&lt;li&gt;根拠のない自信と果てしない理想を漠然と持った人&lt;/li&gt;
&lt;li&gt;自分の存在意義を実現するために会社にする人&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;概ね、この5つに分類できると思います。
せっかくなので、それぞれのタイプの人を解説してみましょう。ちなみにボクは5個目の「自分の存在意義を・・・」のタイプです。&lt;/p&gt;

&lt;h2 id=&#34;社長-という言葉に魅力を感じる人&#34;&gt;「社長」という言葉に魅力を感じる人&lt;/h2&gt;

&lt;p&gt;若い人に多い。すぐにやめたほうがいい。「社長」と呼ばれたり、トップであるという仮想権力に魅力を感じる人。本当に有能な経営者は「社長」という言葉を使う。例えば、一般的な「社長」というイメージを利用して業務を円滑に進めたり、交渉を有利にすすめたり、組織の関係性を明示化するために使う。決してつかわれてはならない。&lt;/p&gt;

&lt;h2 id=&#34;親の代から引き継いで2代目になる人&#34;&gt;親の代から引き継いで2代目になる人&lt;/h2&gt;

&lt;p&gt;社長っぽい。野心というよりは改革に積極的で柔軟であるケースが多い。多分、2代目としての意味を全うするというところに重きをおいているのだと思う。「会社というものはこういうものだ」という感受性が強い場合も多い。親の背中を追って、肌身で経営を身近に感じ続けることができたからであろう。いい人が多い。&lt;/p&gt;

&lt;h2 id=&#34;まわりが必要として社長になる人&#34;&gt;まわりが必要として社長になる人&lt;/h2&gt;

&lt;p&gt;例えば、取引先が「あなたに頼みたいから法人化してくれ」といったり、売れっ子になって法人化したほうが税金面でメリットがあるから法人化するという人たち。とても健全。そうあれたらいいですね。自然の摂理みたいな感じで、こういう人は社長であるべきかなと思います。そこからビジョンをつくっていく人も多い。&lt;/p&gt;

&lt;h2 id=&#34;根拠のない自信と果てしない理想を漠然と持った人&#34;&gt;根拠のない自信と果てしない理想を漠然と持った人&lt;/h2&gt;

&lt;p&gt;「自分はこんなもんじゃない」という自信と、「ビッグなことをやるんだ！」という漠然としたものに突き進める人。盛大な勘違いを起こせる人。こういう人は枝分かれしてまた２パターンくらいに分かれる。一つは、現実と理想にギャップを感じて簡単にやめる人、もうひとつは本当にビッグになる人。&lt;/p&gt;

&lt;h2 id=&#34;自分の存在意義を実現するために会社にする人&#34;&gt;自分の存在意義を実現するために会社にする人&lt;/h2&gt;

&lt;p&gt;これはもとから持っているモヤモヤはなんだろう、なぜ自分は生きているのか？なぜ、存在していいのか？ということを考えるタイプで、何かとりあえず手を動かしながら、考え続けることによって確信していく場合もある。自分の存在意義を第一にするため、社会的な発展を望んでいたり、より多くの人に影響をあたえるようなことに関心をもちやすい。存在意義とつながっているので、何があっても拭えない。もくもくと淡々とやっていく。es（超自我）に気づいてしまった人。&lt;/p&gt;

&lt;p&gt;我ながら良い分類ができたと思う。なので、経営者は「社長」という言葉で片付けるといろいろ正しく受け止められなくなるくらい幅をもった人たちであるということを理解すべきです。&lt;/p&gt;

&lt;p&gt;本当に幸せに生きたいのであれば、絞ることだとボクは思います。たとえば、結婚も愛する人を「絞る」ということだろうし、誇りを持った職人さんも技術を「絞る」ということであります。フォーカスすることで人は幸せになれるのだと思います。逆に言えば、「捨てる」ことでもある。たとえば、過去の辛いことを忘れるというのも「捨てる」一種だ。持ち続けることはやっぱり負担なのだ。「絞る」術や「捨てる」術がないときは、いろいろやってみるしかない。自分の感じることに素直になりながら、ただ、変化していくしかない。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>プログラミングの不思議</title>
      <link>http://jp.atsushimori.com/programming-mystery/</link>
      <pubDate>Wed, 07 Dec 2016 02:09:39 +0900</pubDate>
      
      <guid>http://jp.atsushimori.com/programming-mystery/</guid>
      <description>&lt;p&gt;いろいろと考えてみて、いろいろやってみるんだけど、やっぱりうまくいかなくて、寝て、起きて、散歩して、しばらくするといつの間にかできている。&lt;/p&gt;

&lt;p&gt;そんな不思議があります。向き合っていると必ず新しいことができるようになる。それがプログラミング。&lt;/p&gt;

&lt;p&gt;そして、プログラミングをする上で大事だなと思ったのは、最初の段階から求めすぎないこと。&lt;/p&gt;

&lt;p&gt;リーンスタートアップをはじめとして、ビジネス的にもよくいわれていることであるのですが、プログラミングにおいてもそれは言えるようです。スタートは自分の技術に自身があるからトライしてみるもので、あの製品を超えてやろうとか、云々考えるのですけど、思ったより実力がなくて、少々行き詰まる。こうしてつくっていくから更に技術力が上がるという見方もあるのですが、最初のり想像が高すぎてしまうと、途中でバテてしまうというリスクが生じます。できる範囲でまずは大枠をつくり、形にする。それで、部分的にブラッシュアップしていくのが良さそうであります。&lt;/p&gt;

&lt;p&gt;部分的なブラッシュアップというのは例えば、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;関数の簡略化・動作速度の向上&lt;/li&gt;
&lt;li&gt;部分的により効率の良いアルゴリズムに書き換えること&lt;/li&gt;
&lt;li&gt;製品として長けているところをより良くする機能を追加すること（あるいはフォーカスすること）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;などです。&lt;/p&gt;

&lt;p&gt;そうすることで、数日の間にプロトタイピングが終わり、一旦達成感を味わったあとで、次の課題に取り組める。課題の分割をすることで、気持ちよくプログラミングを継続的に行うことができるという点で、こうした進め方がいいなと個人的に思いました。&lt;/p&gt;

&lt;p&gt;今はElectronでMacアプリをつくっています。Javascriptって奥深いなーなんて感じてます。話は変わりますが、新しい技術的な入門にドットインストールがわかりやすくていいなと思うんですけど、解説をしている田口元氏は本当にすごすぎる。いや、たしかに言語を超えて共通の理解ってのはあるけど、そもそもプロパティやメソッドを覚えなきゃいけないなんてことはザラにあるわけで、それを解説できるレベルで何十言語も扱っている感じ、本当にすごすぎる。一体どんな生活をしているんだろう。。マイナーっぽいレッスンを聞くと疲れ気味な感じの時があって、裏側の苦労を想造してしまう。回し者ではないですが、ドットインストールは本当に社会的意義のあるサービス。&lt;/p&gt;

&lt;p&gt;話はそれましたが、プログラミング時に急に悟るみたいな体験をなんどもしているので、不思議だなーと思ってブログを書いてみました。&lt;/p&gt;

&lt;p&gt;ではでは。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>フレームワークという魔法の言葉</title>
      <link>http://jp.atsushimori.com/no-framework/</link>
      <pubDate>Thu, 01 Dec 2016 15:05:47 +0900</pubDate>
      
      <guid>http://jp.atsushimori.com/no-framework/</guid>
      <description>

&lt;p&gt;プログラミングをやっていると、「フレームワーク」という言葉に幾度となく触れることとなります。Wordpressという単体の存在だった言葉も、いつしか「フレームワークはWordpressです」と「フレームワーク」という言葉の中に位置づけされるようになっていきます。WordpressにRuby on RailsにExpress・・・わたしたちはまるでフレームワークという建物の中を移動しながら生きているような錯覚に陥ります。もちろん、フレームワークが悪いわけではありません。開発効率はよくなるし、複数のプログラマー間でも共通の認識をもったままスムーズにプロジェクトを進めることができます。フレームワークに思想がくっつくのもこの「共通認識によるプロジェクトの一体感をつくる」ための仕組みの一つでしょう。&lt;/p&gt;

&lt;p&gt;結局、何が言いたいのか？&lt;/p&gt;

&lt;p&gt;フレームワークに依存しない方法を積極的に探っていくことがプログラマーとしてあるべき道なんじゃないかということを言いたいのです。フレームワークを使うべきではないということではなく、流行に乗っかったフレームワーク選定ではなく、正しいフレームワーク選びが必要だということです。逆にフレームワークを使わないということは、たとえばリアルタイム通信を実現したい時に、Websocketを一から組むしかない・・という結論になり、時間が無駄になりかねません。今ではSocket.ioなどもあるので、うまく使えば数十分で形にできますので、積極的に使わない手はありません。&lt;/p&gt;

&lt;h2 id=&#34;間違ったフレームワークの選び方&#34;&gt;間違ったフレームワークの選び方&lt;/h2&gt;

&lt;p&gt;主観なので、人によっては無視してほしいですが、ボクが考える間違ったフレームワークの選定プロセスは以下です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;「言語＋フレームワーク」でググる&lt;/li&gt;
&lt;li&gt;その中で、盛り上がっているフレームワークを2-3ピックアップ&lt;/li&gt;
&lt;li&gt;やっぱり人気のあるフレームワークならドキュメントやコミュニティが整ってるし、一番Githubスターの付いているこれにしよう！&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;晴れてあなたは新たなフレームワークの習得に励み、想定内の作業量と時間でプロジェクトを作り上げることができます。&lt;/p&gt;

&lt;h2 id=&#34;正しいフレームワークの選び方&#34;&gt;正しいフレームワークの選び方&lt;/h2&gt;

&lt;p&gt;それに対して、ボクが思う最適なフレームワークの選び方はこうです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;まずは、プロジェクトの実現したい機能を整理する（要件定義）&lt;/li&gt;
&lt;li&gt;要件を小分けにする（リアルタイム通信ができる、保守しやすい、◯日でプロトタイプができる・・・という結構適当な分け方でOKだと思います。）&lt;/li&gt;
&lt;li&gt;小分けにした条件それぞれのシンプルな解決方法をググる&lt;/li&gt;
&lt;li&gt;それらを網羅するフレームワークを調べる&lt;/li&gt;
&lt;li&gt;小分け解決法とフレームワークを比較する（学習コスト、知識の永続性、開発時間、金銭コスト）&lt;/li&gt;
&lt;li&gt;最終的に使う方法を決定する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;間違ったフレームワークとの違いは、課題を細分化するという点です。フルスタックのフレームワークであろうと、ミニマムなフレームワークでろうと、フレームワークという時点でやっぱりモリモリ機能が入っていますので、ミニマムという言葉に騙されてはいけません。場合によっては階層を落としたフレームワーク（たとえば、node.jsのフレームワークとあるけど、希望している機能はnode.jsの機能で代用可能？といった問いをかけることです。）を利用することで解決することが可能です。それを先に調べておけば、ExpressにMeteorにとそれぞれのフレームワークを覚えなくとも、機能を実現できるのではないでしょうか。（node.jsは割りとコアフレームワークかと思いますので、他の課題解決に転用しやすいこともポイント）&lt;/p&gt;

&lt;h2 id=&#34;便利-便利-不便&#34;&gt;便利 + 便利 = 不便&lt;/h2&gt;

&lt;p&gt;そもそもフレームワークは誰か個人の思想から発生するものです。それが競争していくことで、その市場が活発になるという見方もできますが、誰かがつくった便利な仕組みを更に便利に使用と進化を続けていくと、一番最初の機能になっている言語本来の機能が隠されて発展していきます。もともとは1行で書けたスクリプトも、フレームワークを機能させるために数十行になっていることだってあると思います。また、フレームワークはある種の一家みたいなもので、同じ屋根の下であれば心地よいのですが、一度海原に出ようものなら何をそんな冗長な書き方をしているんだ！と一喝されることだってあるのではないでしょうか。もし、そのフレームワークがこの先ずっと使えるというのならフレームワークが言語の代わりとなればよいのですが、残念ながらフレームワークはコロコロかわります。それは先述の通り、市場が活発になる、つまり競争が生まれるからなのです。フレームワークを乗り換えることはなかなか労力がいります。とりあえず触れてみる程度ならまったく躊躇せず使えると思いますが、製品レベルで作ろうというときはきっと深い機能までの理解が必要になるでしょう。その結果、テクノロジーの進化の恩恵をしばらく横目で見ることになるのです。&lt;/p&gt;

&lt;p&gt;Wordpressが良い例です。シンプルなフロント開発でWordpress以前というのはHTMLで直書きしていたり、独自CMSを開発するという流れが多かったはずです。こんなに便利なものはなかった！というインパクトと共にWordpressはヒットしたオープンソースとなりましたが、それから積極的により良い方法を模索したプログラマーがどれだけいるでしょうか？プラットフォームとしてWordpressは良いし、UIなどもなんだかんだで使いやすい。ぼーっとしていたら変えるメリットよりも変えるデメリットの方に焦点があたりがちです。しかし、今Webというプラットフォームの可能性は広がってきています。node.jsは一種切り開いた感があるなと個人的に感じています。そうしたテクノロジーの原理をしることで、すでにWordpressよりも良い選択肢というのは存在しているのに、みんなWordpressを使い続けています。せいぜいプラグインを入れてAMPに対応するという進歩にとどまっています。&lt;/p&gt;

&lt;p&gt;少し話は変わりますが、大規模になればなるほど、フレームワークはその真価を発揮すると思います。そもそも開発が数十名単位になれば、共通認識をもたせにくくなるということもありますし、個々のコードの違いがいわゆる「負の遺産」を産むことだってあります。プログラマーのレベルに幅があることも要因のひとつですね。そんなときはフレームワークを使ったほうが良いケースも往々にしてあると思います。必然的にそれなりの大企業になるでしょう。そうした企業では正しいフレームワークが広がり、力技が可能な大企業がその力を利用して個人に向けてそうした情報を発信する。その結果、ある種のフレームワークランキングが生成され、それに従ってフレームワーカーが増える。そんな構図が目に浮かびますが、みんながみんなフレームワークが必要な規模のプロジェクトを抱えているかというと実際はそうではないと思うのです。&lt;/p&gt;

&lt;p&gt;ましてや、個人レベルであれば、工夫次第で工程をミニマム化できることが多いと思うのです。でも、「フレームワーク」というのはそもそも便利に何かを作るための仕組みという固定概念が多くの人の中にあるので、疑わなくなります。結果的に実は不便になっているケースに気づきづらいのです。&lt;/p&gt;

&lt;h2 id=&#34;フレームワークは洋服&#34;&gt;フレームワークは洋服&lt;/h2&gt;

&lt;p&gt;フレームワークというのはそのトレンド感などもまとうという点で、洋服に似ています。流行りを重視する人もいれば、機能性を重視することもできる。ただ、トレンドの服装を着こなせなければダサくなるということです。ファッションのうまいひとは、トレンドを取り入れつつも普遍的な哲学やテクニックを持ち合わせています。鍛えた身体でサラッとTシャツをかっこよく着こなすみたいなことをプログラミングに置き換えてやっていきたいというのがボクの方針です。外国人はオシャレレベルが高そう、外国人はプログラミングレベルが高そうという魔法もファッションとプログラミングでなんか似ていますね。&lt;/p&gt;

&lt;p&gt;まとめます。&lt;/p&gt;

&lt;p&gt;フレームワークの前に言語レベルでの実装について興味をもってみましょう。そうするとフレームワークの便利さや本質的なネックなどがわかるようになるという利点があります。自分自身がフレームワークに手を出しまくっていて、ずっと「なんかなー、これでいいのかなー」という疑問を持っていたのですが、最近このような考えにまとまったので記事にしてみました。&lt;/p&gt;

&lt;p&gt;では。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>どういったケースのときにSQLiteを選択すべきか</title>
      <link>http://jp.atsushimori.com/which-case-use-sqlite-database/</link>
      <pubDate>Wed, 30 Nov 2016 17:37:43 +0900</pubDate>
      
      <guid>http://jp.atsushimori.com/which-case-use-sqlite-database/</guid>
      <description>

&lt;p&gt;静的サイトジェネレーターをつくっていて、クライアントとなるアプリの設定ファイルやバックアップファイルをどうやって管理しようかと考えていて、SQLiteという選択肢が良さそうな気がしてきたので、考察を書いてみます。&lt;/p&gt;

&lt;p&gt;最終的には静的サイトジェネレーターの使用データを蓄積して人工知能にくわせるというのが目的なので、定期的にユーザーデータを取得し続ける必要がある。本当はローカル完結でいいんだけど、Webを革新していくために人工知能用のデータが必要なのです。だから、そこらへんのスケールを考慮して結論を出してみました。&lt;/p&gt;

&lt;p&gt;結論を先に述べます。各ユーザーのデータはSQLiteで管理し、そのSQLiteのデータを定期的にサーバーへプッシュする。サーバー側のビッグデータはMySQLやPostgreSQLに変換してビッグデータとして扱う。これでいこうと思います。&lt;/p&gt;

&lt;p&gt;さて、最近ではMemSQLなどのDBなどが高速に動作するとして注目されていたりしますが、直近のサービスで使用するにはまだ躊躇してしまう印象です。そこで、最近よく使われるDBのなかで、書き込みや読み込み速度がある程度早くて、簡単に取り扱うことができるものを選ぼうと思い、ググって調べてSQLiteにたどり着いたわけです。&lt;/p&gt;

&lt;p&gt;Ruby on Railsなど、フレームワークのデフォルトDBとして利用されるケースもまぁまぁあると思うのですが、「小規模に向く」みたいなことが頭によぎって、サービスを拡大させたい頭のみなさんはMySQLなどの他のDBに差し替えて使用しているケースも多い印象です。それは気持ち的にわかるのですが、果たしてSQLiteはどの程度のデータを扱う場合に使えるのでしょうか？小規模とは？というところを調べてみました。実際は多角的に判断すべきであるとは思いつつ、とりあえずわかりやすい指標として、数量系について調べてみました。&lt;/p&gt;

&lt;h2 id=&#34;sqliteの全体サイズの上限は32tb&#34;&gt;SQLiteの全体サイズの上限は32TB&lt;/h2&gt;

&lt;p&gt;列数は32767、データサイズは1GBが上限とのこと。比較としてMySQLは全体サイズ無制限、データサイズ無制限ということで、やっぱりビッグデータを扱う場合に有力な候補となりえるみたいですね。ところで、全体サイズとデータサイズの違いは？と思いました。ちょっと違いがわからないですね。軽く調べてもわからないのであきらめました。このデータサイズは１つのDBの容量でしょうか？そう過程すると、1GBなので、全角日本語で5億6000万文字程度とのことで、まぁまぁの量が入りますね。画像を扱ってくる全然違う気がしますが、とりあえず設定ファイル用途としてはしばらくいけそうです。&lt;/p&gt;

&lt;h2 id=&#34;なぜ-yamlやtoml-jsonを使わないのか&#34;&gt;なぜ、YAMLやTOML、JSONを使わないのか？&lt;/h2&gt;

&lt;p&gt;もちろん選択肢として考えました。特にJSONはアプリケーションから呼び出したりするのにもいいし、Pjax、Ajaxとの相性も良さそうなので利用は悩みました。ただ、データを永続化し、且つ整理しながら蓄積していくためには設定ファイルのフォーマットよりはデータベースでやり取りしたほうが効率が良いと考え、SQLiteを選択しました。本当はもっとシンプルなフォーマットを自分でつくっちゃえばいいんでしょうけど、データのやりとりの調整に時間がかかってしまいそうなので、すでにあるものでやったほうが良いのだろうと思いあきらめました。&lt;/p&gt;

&lt;h2 id=&#34;sqliteはmac標準で入ってるというのも選んだポイント&#34;&gt;SQLiteはMac標準で入ってるというのも選んだポイント&lt;/h2&gt;

&lt;p&gt;SQLite3はMacにデフォルトで入っているようです。（どのバージョンからかは調べていませんが。。）最初のクライアントはmacOSアプリなので、Macユーザーを対象にすると、割りと障壁を回避できそうだなと思い、これもSQLiteを選んだ理由の一つです。Core Dataとして扱う手もあると思いますが、つくっている静的サイトジェネレーターからたとえばWordpress用のデータにエクスポートする、あるいは逆にインポートすると考えたときに、データが切り分けられているのは何かとメリットがあると思い、データベースでの管理を重要視しました。&lt;/p&gt;

&lt;p&gt;プロダクト的にメインフィールドがローカルというところもあるので、扱いやすさを優先しても良いかなと思いました。クラウドサービスだとセキュリティーとかいろいろ考えなきゃいけないと思いますが、とりあえずは良しとしましょう。SQLiteはシンプルにファイルなのがいいですね、保存製に優れている点も魅力です。MySQLのようにそもそもデータにエクスポートする必要がないみたいなので、シンプルにしたいボクの思考にピッタリとはまりました。&lt;/p&gt;

&lt;p&gt;逆に、RailsなどがなぜSQLiteをデフォルトDBにしたのかも意図がわかりました。「細かいことを気にせずたのしもうぜ！」そういう意図が垣間見えます。フレームワークの設計意図を考えるとそのフレームワークの思想も反映されていたりするということに気づき、おもしろいなーと改めて思いました。&lt;/p&gt;

&lt;p&gt;気が向いたらSQLiteをつなぎこむコードなんかも公開していきたいですが、とりあえずは考察ということでまた。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>C&#43;&#43;でhtmlファイルを連結する方法</title>
      <link>http://jp.atsushimori.com/how-to-linke-html-files/</link>
      <pubDate>Sat, 26 Nov 2016 15:12:23 +0900</pubDate>
      
      <guid>http://jp.atsushimori.com/how-to-linke-html-files/</guid>
      <description>

&lt;p&gt;静的サイトジェネレータをつくっていて、C++で複数のHTMLファイル（.txtファイルでもよいですが）を連結する方法を探していたものの、簡単すぎてみんな躓かないのか、方法がわからずにいました。結局、ゼロから考えてシンプルな方法、理屈で方法を実現してみたのでc++のファイル連結レベルで躓いてしまうあなたのためにシェアしておきたいと思います！（意外とシンプル）&lt;/p&gt;

&lt;h2 id=&#34;c-erはガチ勢が多い&#34;&gt;C++erはガチ勢が多い？&lt;/h2&gt;

&lt;p&gt;C++を実務レベルで使ってる人ははっきり言って優秀すぎて初心者には理解できないレベルのシェアをしているような。ファイル連結？簡単だよこうやってこうやって・・・というソースはあれど、理解ができないので、使ったとしても制御できないので使いづらい。いろいろやって連結したり、ファイルの内容をコピーして書き出しファイルに連結して貼り付ければよいとかそんな感じでしたが、ちょっとわかりません。&lt;/p&gt;

&lt;h2 id=&#34;難しいことがきらいなのでシンプルに考えてみた&#34;&gt;難しいことがきらいなのでシンプルに考えてみた&lt;/h2&gt;

&lt;p&gt;今回は、とある外部ファイルを変数に入れて、それを使用して別のHTMLファイルを書き出すということをやってみました。以下のサンプルコードでは仮にheaderテンプレートファイルを別ファイルに書き出すということをやっています。
ながれとしてはシンプルにifstream（ファイルの入力）を使って外部ファイルを読み込み、それを変数へ格納、ofstream（ファイルの出力）でhtmlファイルを書き出すという流れです。htmlファイルとはただのテキストファイルと変わりませんので、.txtファイルなどでも同じことができます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt; // これはコンソールの入出力とかを扱うやつです。
#include &amp;lt;fstream&amp;gt; // これがファイルの入出力
#include &amp;lt;sys/stat.h&amp;gt; // 以下２つはディレクトリ操作につかいます。mkdirとか。
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;string&amp;gt; // 文字列を扱うやつです。

using namespace std;

int main() {

  // ifstreamで別ディレクトリにあるheader.htmlファイルを読み込む
  ifstream head(&amp;quot;any_dir/header.html&amp;quot;);

  // ファイルがなかったときのエラー処理とか入れたほうがいいかも。
  if (!head) {
      cout &amp;lt;&amp;lt; &amp;quot;File not found!&amp;quot; &amp;lt;&amp;lt; endl;
      return 0;
  }

  // 文字列の変数に格納、今回はファイルの中身を１行ずつ読み込んでいるのでwhileでまわします。
  string f_header = &amp;quot;&amp;quot;;
  string header_template = &amp;quot;&amp;quot;;
  while (getline(header,f_head)) {
    header_template = header_template + f_header;
  }

  // これは生成するディレクトリがあるかどうかを判定しています。
  struct stat st;
  if(stat(&amp;quot;production&amp;quot;, &amp;amp;st) != 0){
    mkdir(&amp;quot;production&amp;quot;, 0775);
  }

  // 書き出し部分productionという」ディレクトリをつくってその中にindex.htmlを書き出します。
  ofstream html(&amp;quot;production/index.html&amp;quot;);
  html &amp;lt;&amp;lt; header_template;
  html &amp;lt;&amp;lt; &amp;quot;やったーヘッダーファイルを連結して表示できた！&amp;quot; &amp;lt;&amp;lt; endl;

　// これはあってもなくてもいいですが、成功しました！というのをターミナルに表示するものです。
  cout &amp;lt;&amp;lt; &amp;quot;Success!!&amp;quot; &amp;lt;&amp;lt; endl;

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というわけで、あとは適当にやってみてください。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>これからの時代、個人的にC&#43;&#43;を推していきたい</title>
      <link>http://jp.atsushimori.com/lets-start-cplusplus/</link>
      <pubDate>Thu, 24 Nov 2016 16:09:43 +0900</pubDate>
      
      <guid>http://jp.atsushimori.com/lets-start-cplusplus/</guid>
      <description>

&lt;p&gt;これからC++とかPythonの需要が高まるんじゃないの？という話です。&lt;/p&gt;

&lt;p&gt;ボクはHTMLからはじめ、PHP、Ruby、Scala、Javascript、C++など数々の言語に触れてきました。言語をまたいでいくことで、プログラミングのポイントがつかめるようになり、プログラミングは本当におもしろいとのめり込んでしまいました。&lt;/p&gt;

&lt;p&gt;特に、大きく変わったタイミングというのが、変数の使い方やオブジェクト指向に関して理解したタイミングです。たとえばHTMLではただデザインを忠実に表現するために書くということがメインで、正直かなり昔に飽きました。CSSも同様です。CSSの場合はCSS3のアニメーションやJavascriptとの組み合わせで多少は楽しむことができますが、それもだいたい全体像やできることが理解できてくるともういいやという感じになってしまいます。&lt;/p&gt;

&lt;p&gt;そこで、本題です。現在ボクはC++を使ってまだ世の中にない静的なWebジェネレーターをつくっています。はじめた動機としては、現状の動的なウェブサイトの表示時間が重いと感じていたことが発端です。そこからWebサイトについて考えていくと、今こそWebサイトのあり方を変えていくタイミングなんじゃないかと思うようになりました。速度だけではく、管理の仕方や動的な部分と静的な部分の扱いなど、そして人工知能による進化、つめこみたい機能はたくさんあります。とりえず、カタチにすべく奮闘中です。&lt;/p&gt;

&lt;p&gt;そもそもが性能（速度）を重視するというモチベーションだったので、静的サイトにすることにしました。また、同時にGUIなどがあったほうが便利という人も多いので、多くの方に使っていただけるようにオープンソースあるいは、単に無料提供という形で公開予定です。&lt;/p&gt;

&lt;p&gt;フロントはHTMLを書き出す、書き出すツールとしてC++ということになります。何の言語でもいいかなと思ったのですが、人工知能の開発などもちょくちょくやりはじめているので、C++をある程度自由に使いこなすようになることで、いろいろと相乗効果があるかなという理由でC++を使っています。&lt;/p&gt;

&lt;p&gt;C++というと古い言語というイメージを持つ方もいるかもしれません。ただ、個人的に言語の生まれてからの歳なんてどうでもいいと思っています。むしろ、性能を重視するのであれば自ずと選択肢は限られてきますし。最近はだれでも簡単に扱うことのできる各種フレームワークが充実していて、フレームワーカーがすごく多いなと思いました。それはそれで需要がありますし、良いのだと思うんですが、最高のものを作ろうと思ったら、もう一度作り直す気持ちで、一から精度を高めていくということが必要だと感じています。WordpressやRuby on Railsを使えることでできることは多いですが、かつてのスティーブ・ジョブズのような仕事はできないと思うのです。スティーブ・ジョブズになりたいわけではないですが、根本から覆るような最高の製品を作りたいと思っているので、言語の選択も慎重に行いました。&lt;/p&gt;

&lt;h2 id=&#34;人工知能が中級言語の追い風&#34;&gt;人工知能が中級言語の追い風&lt;/h2&gt;

&lt;p&gt;ちょうど今のタイミングは人工知能に注目が集まっています。個人的な見解ですが、これからプログラマーとして根本的にハックしたいのであれば、C++やPythonを使うことをおすすめしたいと思います。決して古い言語が使えないわけではありません。現にGoogleやFacebookなどの人工知能の開発もC++やPythonが使われるケースが多いように見受けられます。人工知能は本質的に高速に処理する必要があるため、CやC++、Pythonなどがよく使われるというのがあると思います。ハードウェア寄りかWeb寄りかによって、すべてがこれらの言語で書けるかというと現実的には組み合わあせていきますが、中級言語＋PHPや中級言語＋Javascriptなどがより発展していくのではないかなと思っています。特にJavascriptに関してはNode.jsなんかが結構大きな変化で、動的にWebページを扱うツールも新しい形で代替ができそうなので、色々変革の時期かなと感じています。&lt;/p&gt;

&lt;p&gt;一般的にCとかは低級言語と言われる場合もありますが、アセンブリ言語の分類が難しくなるので、中級言語としておきましょう。あまり低級言語に寄り過ぎると、一人で開発しなくてはならなくなるので、あまりおすすめする理由はないですが、中級言語であれば、使える人はたくさんいるし、歴史がある分、方法論にもこまりません。（選択は悩みますが。。。）とまぁ、こんなことを漠然と考えている人はたくさんいると思うので、結果的にC++プログラマーやPythonプログラマーが増え、賑わいそうだなと思っています。楽しみです。&lt;/p&gt;

&lt;p&gt;他の高級言語が悪いという議論ではありません。適材適所なのでどの言語も表現にこまることはあまりないでしょう。ただ、個人的な意見としてC++を推していきたいし、コミュニティーなんかもつくっていけたらと構想しているところです。&lt;/p&gt;

&lt;h2 id=&#34;c-おもしろい&#34;&gt;C++おもしろい&lt;/h2&gt;

&lt;p&gt;特にWeb寄りの開発がメインだったボクの場合は、ファイル操作一つとっても面白いのです。特に自分のMac内の作業をいろいろ自動化したりとか、楽しみが増えた感じがします。メモリの管理とかはまだまだこれからですが、性能を最大限引き出していくという点ではなんだか性に合っていてワクワクするポイントでもあります。もう少し覚えたらサーバーを立ててみたりして、非同期通信とかも実験してみたい今日このごろです。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>